<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Daniel Chang]]></title>
  <link href="http://danielchangNYC.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://danielchangNYC.github.io/"/>
  <updated>2014-01-13T18:58:32-05:00</updated>
  <id>http://danielchangNYC.github.io/</id>
  <author>
    <name><![CDATA[Daniel Chang (couchpanda / c0depanda)]]></name>
    <email><![CDATA[daniel.chang85@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ActiveRecord, Equality, and Rogue]]></title>
    <link href="http://danielchangNYC.github.io/blog/2014/01/12/tdd1-ActiveRecordEqualityRogue/"/>
    <updated>2014-01-12T23:00:00-05:00</updated>
    <id>http://danielchangNYC.github.io/blog/2014/01/12/tdd1-ActiveRecordEqualityRogue</id>
    <content type="html"><![CDATA[<p><img class="<a" src="href="http://static.comicvine.com/uploads/original/8/85629/1887574-rogue1.gif">http://static.comicvine.com/uploads/original/8/85629/1887574-rogue1.gif</a>"> Almost done with my model specs! I ran into a couple of interesting problems that I posted on Stack Overflow, one of which I&rsquo;ll cover briefly below. Oh yeah, and Rogue! I&rsquo;ll explain that in the last section of this post.</p>

<h2>The problem I ran into (from my <a href="https://stackoverflow.com/questions/21102549/why-is-the-where-query-in-rails-returning-a-different-object">StackOverflow post</a>)</h2>

<p><em>If you just read the whole post, skip to the last section of this blog post.</em></p>

<p>I&rsquo;m testing chats between users in my app. I&rsquo;m using RSpec and FactoryGirl</p>

<p>The test that&rsquo;s not passing:</p>

<p><code>ruby chat_spec.rb
it "creates a chat if one does not exist" do
  bob = create(:user, username: "bob")
  dan = create(:user, username: "dan")
  new_chat = Chat.create(user_id: dan.id, chatted_user_id: bob.id)
  expect(Chat.where("chatted_user_id = ?", bob.id).first).to equal(new_chat)
end
</code></p>

<p>The failure message says:</p>

<p>``` sh
Failure/Error: expect(Chat.where(&ldquo;chatted_user_id = ?&rdquo;, bob.id).first).to equal(new_chat)</p>

<p>   expected #&lt;Chat:70120833243920> => #<Chat id: 2, user_id: 2, chatted_user_id: 3></p>

<pre><code>    got #&lt;Chat:70120833276240&gt; =&gt; #&lt;Chat id: 2, user_id: 2, chatted_user_id: 3&gt;
</code></pre>

<p>   Compared using equal?, which compares object identity,
   but expected and actual are not the same object. Use
   <code>expect(actual).to eq(expected)</code> if you don&rsquo;t care about
   object identity in this example.
```</p>

<p>Why is my query returning a different object id?</p>

<h3>Answer from Simone Carletti on StackOverflow</h3>

<p>equal checks object identity. The objects you are testing are two objects (instances) referencing the same record, but they are actually different objects from a Ruby virtual machine point of view.</p>

<p>You should use
<code>ruby
expect(Chat.where("chatted_user_id = ?", bob.id).first).to eq(new_chat)
</code>
To better understand the problem, look at the following example</p>

<p><code>
2.0.0-p353 :001 &gt; "foo".object_id
 =&gt; 70117320944040
2.0.0-p353 :002 &gt; "foo".object_id
 =&gt; 70117320962820
</code>
Here I&rsquo;m creating two identical strings. They are identical, but not equal because they are actually two different objects.</p>

<p><code>
2.0.0-p353 :008 &gt; "foo" == "foo"
 =&gt; true
2.0.0-p353 :009 &gt; "foo".equal? "foo"
 =&gt; false
</code></p>

<p>That&rsquo;s the same issue affecting your test. equal checks if two objects are actually the same at the object_id level. But what you really want to know is if they are the same record.</p>

<h2>So what&rsquo;s happening under the hood?</h2>

<p>The &ldquo;where&rdquo; query returns an array of objects matching the query, and those objects must be Active Record objects that just handle the data. If I make another query, Active Record must be creating another set of objects to handle each row of data.</p>

<p>I wanted to confirm this before throwing it out on the web as &ldquo;fact&rdquo;, so here&rsquo;s what an Active Record object is from <a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">Martin Fowler himself</a>:</p>

<blockquote><p>An object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data.</p></blockquote>

<p>Think of an Active Record object sort of like Rogue (see above). For those of you who don&rsquo;t remember, Rogue absorbs the memories and abilities of any person she touches.</p>

<p><img class="<a" src="href="http://31.media.tumblr.com/25cd14bae1b207202d0ee9b56b475409/tumblr_mzd6fjLYmf1sqhdy2o1_1280.png">http://31.media.tumblr.com/25cd14bae1b207202d0ee9b56b475409/tumblr_mzd6fjLYmf1sqhdy2o1_1280.png</a>" width="480"></p>

<p>Similarly (sorta), an Active Record objects takes the data (memories) of a certain row and then takes on the behavior (abilities) of the object type matching the table name.</p>

<p>Ok, so that was really just an excuse to get Rogue somewhere on my blog. While I&rsquo;m at it, here&rsquo;s one of her destroying Ororo (Storm).</p>

<p><img class="<a" src="href="http://i22.photobucket.com/albums/b310/RogueX18/Rogue%20Absorptions/UncannyX-Men158Storm.jpg">http://i22.photobucket.com/albums/b310/RogueX18/Rogue%20Absorptions/UncannyX-Men158Storm.jpg</a>"></p>

<p>So there you have it! Moral of the story: generally remember to use eq to test equivalence in RSpec with ActiveRecord.</p>

<p>Oh, and here&rsquo;s a <a href="https://www.relishapp.com/rspec/rspec-expectations/v/2-0/docs/matchers/equality-matchers">bonus resource: equal, eql, eq, and ==</a> in RSpec.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How and Why I Began Testing in Ruby on Rails]]></title>
    <link href="http://danielchangNYC.github.io/blog/2014/01/12/tdd0-whyttd/"/>
    <updated>2014-01-12T23:00:00-05:00</updated>
    <id>http://danielchangNYC.github.io/blog/2014/01/12/tdd0-whyttd</id>
    <content type="html"><![CDATA[<p>Testing is one of those things that feels a bit like eating well or going to the gym. Since it&rsquo;s already ten days into the New Year and I have yet to commit to any resolutions, let this be it: no more will I make excuses for skipping testing.</p>

<p>What does this really mean to me though? Am I eating broccoli just because someone told me it&rsquo;s good for me? Here are three reasons that have driven me to make the change.</p>

<h2>TDD Reason 1: Manual Testing Sucks; TDD Saves Time</h2>

<p>My friend told me about the job she left before coming to the Flatiron School and one of her responsibilities looked a bit like this:</p>

<p><img class="<a" src="href="http://blog.polarion.com/wp-content/uploads/2012/12/Screen-Shot-2012-12-06-at-12.07.14-PM.png">http://blog.polarion.com/wp-content/uploads/2012/12/Screen-Shot-2012-12-06-at-12.07.14-PM.png</a>"></p>

<p>What. A. Nightmare. There should be a -phobia for this.</p>

<p>Don&rsquo;t get me wrong &mdash; I&rsquo;m sure this could be pretty efficient if the scope of the UX is very small, or you don&rsquo;t know-how to implement TDD yet. However, how can you be sure your site won&rsquo;t expand, or why not learn how to use a gem like Capybara to save you time in the future? Used in conjuction with Guard, you could really save some serious time while coding!</p>

<h2>TDD Reason 2: Code Confidence</h2>

<p>Now that I&rsquo;ve had a bit more experience writing web apps (still without TDD), I&rsquo;ve had the pleasure of seeing them grow and change throughout development. On the other hand, everytime I implemented a new feature, I had less and less confidence that the rest of my code base would work fine. At some point, the prospect of a new feature started feeling like a laundry list or the guarantee of a new bug. Testing will certainly help me find bugs as I introduce them, and therefore boost my confidence in in my code.</p>

<h2>TDD Reason 3: Thinking Before Doing</h2>

<p>Writing tests before writing production code forces you to clearly iterate what it is you want your application to do before you start coding. Ideally, you want your tests to last as long as possible as well, so it will force you to make important decisions about design as well. The prospect of having well thought-out code with lasting design excites me! I&rsquo;ve had several experiences already of trying to refactor poorly designed code and it&rsquo;s quite painful.</p>

<h2>My Next Steps</h2>

<p>I&rsquo;ve decided to begin my TDD exploration by refactoring my first app, Little Red Wagon (LRW). My current reads are Aaron Sumner&rsquo;s book, <a href="https://leanpub.com/everydayrailsrspec">Everyday Rails Testing with RSpec</a>, and <a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330">Practical Object-Oriented Design in Ruby</a> by Sandi Metz. I&rsquo;m about 30% through each book right now and have written a few model specs already for LRW. I&rsquo;ve decided not to use Factory Girl since it will slow down testing and Rails' built-in fixtures are satisfactory for what I currently have. In any case, the grand plan is to get some hands-on practice writing tests using the TDD book first and then taking on the much larger challenge of redesigning my code base. Thanks for reading, and more updates to come on TDD!</p>
]]></content>
  </entry>
  
</feed>
